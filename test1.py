def search_pairs(array, k):
    array.sort() # сортирую массив по возрастанию
    head = 0 # беру индекс начала массива
    tail = len(array) - 1 # беру индекс конца массива
    list_of_numbers = [] # объявляю массив, в который будем складывать наши пары
    while head < tail:
        sum_ = array[head] + array[tail] # суммируем значения
        if sum_ == k: # проверяем на совпадение с требуемой суммой
            list_of_numbers.append((array[head], array[tail])) # если совпало, то добавляем в массив
            head += 1 # идем на шаг вперед
            tail -= 1 # идем на шаг назад
        else: # если не совпало
            if sum_ < k: head += 1 # проверяем на то, что сумма оказалась меньше. Если так, то идем с головы на шаг вперед
            else: tail -= 1 # если не так, то идем с конца на шаг назад
    return list_of_numbers # возвращаем наш список пар

''' здесь в переменную сохраняем результаты отработки функции, делам set этих значений
    для того, чтобы убрать повторяющиеся значения и опять переводим в list '''
pairs = list(set(search_pairs([1, 2, 6, 5, 3, 4, 7, 8, 3, 2], 5)))
print(pairs)

''' 
Ответ1: O(n)
Ответ2: думаю, что можно. Но пока в голову не приходит как :( 

'''