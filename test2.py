''' Создаю класс собственной ошибки для того, чтобы использовать в дальнейшем в коде '''

class CharError(Exception):
    def __init__(self, *args): # конструктор
        if args: # если мы передадим что-нибудь, то это сохранится в self.message
            self.message = args[0]
        else: # если нет, то self.message пустой
            self.message = None

    def __str__(self): # магический метод для работы со строчным выводом
        if self.message: # еслм сообщение есть, то мы им пользуемся в ошибке
            return f'Ошибка: эта буква не входит в латинский алфавит! Проблема в имени - {self.message}'
        else: # если его нет, то игнорируем
            return 'Ошибка: эта буква не входит в латинский алфавит!'

# Функция для получения имен из файла
def read_file(filename):
    try: # добавляем код в try except, если неправильно ввели название файла
        with open(filename) as f: # зачитываем файл на чтение
            list_of_names = f.read().split('"') # сплитим по двойным кавычкам и формируем массив
    except FileNotFoundError: 
        return 'File not found' # возвращаем ошибку, если файл не нашелся
    for name in list_of_names: # проходимся по именам в массиве
        if name == ',' or name == '': 
            list_of_names.remove(name) # чистим наш массив от мусора (',' | '')
    return list_of_names # возвращаем список имен

# Сортировка списка
def sort_list(list_of_names): return sorted(list_of_names, key=str.lower) # сортируем список имен по требованию

# Делаем все вычисления
def count_sum(list_of_names):
    ALPHABET = {
        'A': 1,
        'B':2,
        'C':3,
        'D':4,
        'E':5,
        'F':6,
        'G':7,
        'H':8,
        'I':9,
        'J':10,
        'K':11,
        'L':12,
        'M':13,
        'N':14,
        'O':15,
        'P':16,
        'Q':17,
        'R':18,
        'S':19,
        'T':20,
        'U':21,
        'V':22,
        'W':23,
        'X':24,
        'Y':25,
        'Z':26
    } # создали алфавитную константу (словарь), где ключ - это буква, а значение - это номер в алфавите

    dict_of_names_sum = {} # объявляем словарь для сумм имен, где ключ - это имя, а значение - это сумма
    for name in list_of_names: # проходимся по именам в списке
        sum_ = 0 # объявляем переменную, которая будет содержать сумму имени
        for char in name: # проходимся по символам в имени
            if char in ALPHABET: # если эта буква входит в алфавит, то мы берем по ключу ее порядковый номер и прибавляем к сумме
                sum_ += ALPHABET[char]
            else:
                raise CharError # если буква не входит в алфавит, то поднимаем нашу собственную ошибку
        dict_of_names_sum[name] = list_of_names.index(name)+1 * sum_ # берем индекс в алфавите, начиная с одного, и умножаем на сумму имени
     
    sum_ = 0 # общая сумма по всем словам
    for k,v in dict_of_names_sum.items(): # проходимся по нашему словарю
        sum_ += v # и суммируем наши значения

    return sum_ # возвращаем сумму всех имен

count = count_sum(sort_list(read_file('names.txt'))) # сохраняем в переменную результат работы трех функций по порядку (зачитываем, сортируем, считаем)
print(count)